---
title: "Creating Widgets"
description: "Step-by-step guide to building React widgets for MCP Apps"
---

# Creating Widgets

This guide walks you through creating a complete MCP widget from scratch.

## Prerequisites

You'll need an existing MCP server project. If you don't have one:

```bash
npx create-mcp-use-app my-server
cd my-server
npm install
```

## Step 1: Create Widget Directory

Widgets live in the `resources/` directory. Create a folder for your widget:

```bash
mkdir -p resources/weather-display
cd resources/weather-display
```

Each widget requires a `widget.tsx` file:

```bash
touch widget.tsx
```

## Step 2: Define Widget Schema

Create `widget.tsx` and define the widget metadata using Zod:

```tsx resources/weather-display/widget.tsx
import { z } from 'zod'
import type { WidgetMetadata } from 'mcp-use/react'

// Define the shape of props your widget receives
const propSchema = z.object({
  city: z.string().describe('The city name'),
  temperature: z.number().describe('Temperature in Celsius'),
  conditions: z.string().describe('Weather conditions'),
  humidity: z.number().optional().describe('Humidity percentage'),
  windSpeed: z.number().optional().describe('Wind speed in km/h')
})

// Export metadata for automatic registration
export const widgetMetadata: WidgetMetadata = {
  description: 'Display weather information in a beautiful card',
  props: propSchema
}

// Infer TypeScript types from schema
type WeatherProps = z.infer<typeof propSchema>
```

<Note>
  The `widgetMetadata` export is **required** for automatic widget discovery. Without it, mcp-use won't register your widget.
</Note>

## Step 3: Create React Component

Add the React component below the metadata:

```tsx resources/weather-display/widget.tsx
import { useWidget, McpUseProvider } from 'mcp-use/react'
import React from 'react'

const WeatherDisplay: React.FC = () => {
  const { props, isPending } = useWidget<WeatherProps>()

  return (
    <McpUseProvider>
      {isPending ? (
        <div className="flex items-center justify-center p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        </div>
      ) : (
        <div className="bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20 rounded-3xl p-8">
          <div className="flex items-start justify-between mb-6">
            <div>
              <h2 className="text-3xl font-bold text-gray-900 dark:text-white">
                {props.city}
              </h2>
              <p className="text-gray-600 dark:text-gray-400 capitalize">
                {props.conditions}
              </p>
            </div>
            <div className="text-right">
              <div className="text-5xl font-bold text-blue-600 dark:text-blue-400">
                {props.temperature}Â°
              </div>
              <div className="text-sm text-gray-500">Celsius</div>
            </div>
          </div>

          {(props.humidity !== undefined || props.windSpeed !== undefined) && (
            <div className="grid grid-cols-2 gap-4 pt-6 border-t border-blue-200 dark:border-blue-800">
              {props.humidity !== undefined && (
                <div>
                  <div className="text-sm text-gray-500 mb-1">Humidity</div>
                  <div className="text-xl font-semibold text-gray-900 dark:text-white">
                    {props.humidity}%
                  </div>
                </div>
              )}
              {props.windSpeed !== undefined && (
                <div>
                  <div className="text-sm text-gray-500 mb-1">Wind Speed</div>
                  <div className="text-xl font-semibold text-gray-900 dark:text-white">
                    {props.windSpeed} km/h
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      )}
    </McpUseProvider>
  )
}

export default WeatherDisplay
```

### Key Components

**`useWidget<TProps>()`**
- Returns props sent from the server
- Provides `isPending` state during tool execution
- Access to platform APIs (`callTool`, `setState`, etc.)

**`McpUseProvider`**
- Required wrapper for all widgets
- Provides theme context and platform detection
- Optional features: `debugger`, `viewControls`, `autoSize`

**`isPending` State**
- `true` while the tool is executing on the server
- `false` once data is available
- Use to show loading states

## Step 4: Add Styling

Create a `styles.css` file in your resources directory:

```css resources/styles.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom styles */
.animate-spin {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
```

Import it in your widget:

```tsx
import './styles.css'
```

## Step 5: Configure Server Tool

Now create a tool that uses your widget. In your server's `index.ts`:

```typescript index.ts
import { MCPServer, widget } from 'mcp-use/server'
import { z } from 'zod'

const server = new MCPServer({
  name: 'weather-server',
  version: '1.0.0'
})

// Option 1: Let the widget auto-register as a tool
// The widget is automatically available as "weather-display" tool

// Option 2: Create a custom tool that uses the widget
server.tool({
  name: 'get-weather',
  description: 'Get current weather for a city',
  schema: z.object({
    city: z.string().describe('City name')
  }),
  widget: {
    name: 'weather-display', // References your widget
    invoking: 'Fetching weather data...',
    invoked: 'Weather data loaded'
  }
}, async ({ city }) => {
  // Fetch weather data from API
  const weatherData = await fetchWeather(city)

  // Return widget with props
  return widget({
    props: {
      city,
      temperature: weatherData.temp,
      conditions: weatherData.conditions,
      humidity: weatherData.humidity,
      windSpeed: weatherData.windSpeed
    },
    message: `Current weather in ${city}`
  })
})

await server.listen()
```

## Step 6: Run Development Server

Start the dev server with hot reload:

```bash
npm run dev
```

Your widget is now available at:
- **Tool**: `get-weather`
- **Resource**: `ui://widget/weather-display`

## Step 7: Test the Widget

### In Inspector

The mcp-use inspector provides a built-in testing environment:

```bash
mcp-use inspect
```

Navigate to `http://localhost:5173/inspector` and test your tool.

### In ChatGPT

Connect your server to ChatGPT:

1. Start your server: `npm run dev`
2. Use ngrok or similar to expose it: `ngrok http 3000`
3. Add the server URL to ChatGPT
4. Test in a conversation: "What's the weather in Tokyo?"

### In Claude Desktop

Add your server to Claude's config:

```json ~/.config/claude/mcp.json
{
  "mcpServers": {
    "weather": {
      "url": "http://localhost:3000/mcp"
    }
  }
}
```

Restart Claude Desktop and test.

## Advanced Features

### Interactive Actions

Add buttons that call tools:

```tsx
import { useWidget } from 'mcp-use/react'

const WeatherDisplay = () => {
  const { props, callTool } = useWidget<WeatherProps>()

  const handleRefresh = async () => {
    await callTool('get-weather', { city: props.city })
  }

  return (
    <div>
      {/* ... weather display ... */}
      <button
        onClick={handleRefresh}
        className="mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg"
      >
        Refresh
      </button>
    </div>
  )
}
```

### State Management

Persist data across turns:

```tsx
import { useWidget } from 'mcp-use/react'

const WeatherDisplay = () => {
  const { props, state, setState } = useWidget<
    WeatherProps,
    any,
    any,
    { favorites: string[] }
  >()

  const addToFavorites = async () => {
    await setState(prev => ({
      favorites: [...(prev?.favorites || []), props.city]
    }))
  }

  return (
    <div>
      {/* ... weather display ... */}
      <button onClick={addToFavorites}>
        Add to Favorites
      </button>
      <div>
        Favorites: {state?.favorites?.join(', ')}
      </div>
    </div>
  )
}
```

### Loading External Data

Fetch data from APIs:

```tsx
import { useWidget } from 'mcp-use/react'
import { useEffect, useState } from 'react'

const WeatherDisplay = () => {
  const { props, mcp_url } = useWidget<WeatherProps>()
  const [forecast, setForecast] = useState(null)

  useEffect(() => {
    fetch(`${mcp_url}/api/forecast?city=${props.city}`)
      .then(res => res.json())
      .then(setForecast)
  }, [props.city])

  return (
    <div>
      <h2>{props.city}</h2>
      {forecast && (
        <div>5-day forecast: {forecast.days.join(', ')}</div>
      )}
    </div>
  )
}
```

<Note>
  The `mcp_url` from `useWidget` provides the base URL of your MCP server for API calls.
</Note>

## Widget Configuration Options

### Prevent Auto-Registration

Disable automatic tool registration:

```tsx
export const widgetMetadata: WidgetMetadata = {
  description: 'My widget',
  props: propSchema,
  exposeAsTool: false // Widget won't auto-register as a tool
}
```

Use this when:
- Multiple tools use the same widget
- You want custom tool parameters different from widget props
- The widget is only for internal use

### Annotations

Add hints for the AI:

```tsx
export const widgetMetadata: WidgetMetadata = {
  description: 'Weather display',
  props: propSchema,
  annotations: {
    readOnlyHint: true, // Widget is read-only, no user input expected
    destructive: false   // Widget doesn't modify data
  }
}
```

## Best Practices

### 1. Always Handle Loading States

```tsx
const { props, isPending } = useWidget<Props>()

if (isPending) {
  return <LoadingSpinner />
}

return <YourWidget {...props} />
```

### 2. Use Semantic HTML

```tsx
<article>
  <header>
    <h2>{props.title}</h2>
  </header>
  <section>{props.content}</section>
</article>
```

### 3. Support Dark Mode

```tsx
<div className="bg-white dark:bg-gray-800 text-gray-900 dark:text-white">
  Content
</div>
```

### 4. Validate Props

Use Zod for runtime validation:

```tsx
const propSchema = z.object({
  city: z.string().min(1),
  temperature: z.number().min(-100).max(100)
})
```

### 5. Add Accessibility

```tsx
<button
  onClick={handleClick}
  aria-label="Refresh weather data"
  disabled={isPending}
>
  Refresh
</button>
```

## Troubleshooting

### Widget Not Showing

1. Check `widgetMetadata` is exported
2. Verify widget is in `resources/` directory
3. Check server logs for errors
4. Restart dev server

### Props Are Empty

1. Verify tool is passing props via `widget({ props: {...} })`
2. Check Zod schema matches props structure
3. Check browser console for errors

### Styling Not Working

1. Verify `styles.css` is imported
2. Check Tailwind CSS is configured
3. Verify dark mode classes are correct

## Next Steps

<CardGroup cols={2}>
  <Card title="React Hooks" icon="react" href="/typescript/apps/react-hooks">
    Deep dive into useWidget, useCallTool, and more
  </Card>
  <Card title="Theming" icon="palette" href="/typescript/apps/theming">
    Style widgets with dark mode and design tokens
  </Card>
  <Card title="ChatGPT Integration" icon="openai" href="/typescript/apps/chatgpt-integration">
    Deploy your widget to ChatGPT
  </Card>
  <Card title="Server Widgets" icon="server" href="/typescript/server/widgets">
    Learn about server-side widget configuration
  </Card>
</CardGroup>
