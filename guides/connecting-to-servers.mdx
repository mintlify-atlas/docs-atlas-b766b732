---
title: "Connecting to MCP Servers"
description: "Learn different ways to connect clients to MCP servers"
icon: "plug"
---

## Overview

There are multiple ways to connect to MCP servers depending on your use case:

<CardGroup cols={2}>
  <Card title="Local Processes (stdio)" icon="terminal">
    Connect to servers running as local processes
  </Card>
  <Card title="HTTP/SSE Servers" icon="globe">
    Connect to servers over HTTP with Server-Sent Events
  </Card>
  <Card title="WebSocket Servers" icon="satellite-dish">
    Real-time bidirectional communication
  </Card>
  <Card title="Sandboxed (E2B)" icon="box">
    Run servers in isolated cloud containers
  </Card>
</CardGroup>

## Connection Methods

### 1. stdio Transport (Local Processes)

The simplest way to connect to MCP servers running as local processes:

<Tabs>
  <Tab title="TypeScript">

```typescript
import { MCPClient } from "mcp-use/client";

const config = {
  mcpServers: {
    filesystem: {
      command: "npx",
      args: ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
      env: {
        DEBUG: "true",  // Optional environment variables
      },
    },
    playwright: {
      command: "npx",
      args: ["@playwright/mcp@latest"],
    },
  },
};

const client = MCPClient.fromDict(config);
await client.createAllSessions();

// Use the client
const tools = await client.getTools();
console.log("Available tools:", tools.map(t => t.name));
```

**When to use:**
- Local development
- Command-line tools
- No network setup needed
- Process isolation

</Tab>
  
  <Tab title="Python">

```python
import asyncio
from mcp_use import MCPClient

async def main():
    config = {
        "mcpServers": {
            "filesystem": {
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
                "env": {
                    "DEBUG": "true",
                },
            },
            "playwright": {
                "command": "npx",
                "args": ["@playwright/mcp@latest"],
            },
        }
    }
    
    client = MCPClient.from_dict(config)
    await client.create_all_sessions()
    
    # Use the client
    tools = await client.get_tools()
    print(f"Available tools: {[t['name'] for t in tools]}")
    
    await client.close_all_sessions()

if __name__ == "__main__":
    asyncio.run(main())
```

  </Tab>
</Tabs>

### 2. HTTP/SSE Transport

Connect to MCP servers running as HTTP services:

<Tabs>
  <Tab title="TypeScript">

```typescript
import { MCPClient } from "mcp-use/client";

const config = {
  mcpServers: {
    weather: {
      url: "http://localhost:3000/mcp",  // HTTP URL
    },
    remote: {
      url: "https://api.example.com/mcp",  // Remote server
      headers: {  // Optional custom headers
        "Authorization": "Bearer token",
      },
    },
  },
};

const client = MCPClient.fromDict(config);
await client.createAllSessions();
```

**When to use:**
- Remote servers
- Cloud deployments
- Browser-based clients
- Need HTTP features (caching, load balancing)

</Tab>
  
  <Tab title="Python">

```python
config = {
    "mcpServers": {
        "weather": {
            "url": "http://localhost:8000/mcp",
        },
        "remote": {
            "url": "https://api.example.com/mcp",
        },
    }
}

client = MCPClient.from_dict(config)
await client.create_all_sessions()
```

  </Tab>
</Tabs>

### 3. Configuration from File

Store configuration in a JSON file:

**config.json:**
```json
{
  "mcpServers": {
    "local-server": {
      "command": "node",
      "args": ["./dist/server.js"]
    },
    "remote-server": {
      "url": "http://localhost:3000/mcp"
    }
  }
}
```

<Tabs>
  <Tab title="TypeScript">

```typescript
import { MCPClient } from "mcp-use/client";

const client = MCPClient.fromConfigFile("./config.json");
await client.createAllSessions();
```

  </Tab>
  
  <Tab title="Python">

```python
from mcp_use import MCPClient

client = MCPClient.from_config_file("./config.json")
await client.create_all_sessions()
```

  </Tab>
</Tabs>

### 4. Sandboxed Execution (E2B)

Run MCP servers in isolated cloud containers:

<Tabs>
  <Tab title="Python">

```python
import os
from mcp_use import MCPClient
from mcp_use.types.sandbox import SandboxOptions

config = {
    "mcpServers": {
        "everything": {
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-everything"],
        }
    }
}

sandbox_options: SandboxOptions = {
    "api_key": os.getenv("E2B_API_KEY"),
    "sandbox_template_id": "base",
}

client = MCPClient(
    config=config,
    sandbox=True,
    sandbox_options=sandbox_options,
)

await client.create_all_sessions()
```

**Benefits:**
- No local dependencies
- Secure isolation
- Consistent environment
- Cloud-based execution

**Setup:**
```bash
pip install "mcp-use[e2b]"
export E2B_API_KEY=your_api_key
```

  </Tab>
</Tabs>

## Using MCPClient

### Basic Operations

<Tabs>
  <Tab title="TypeScript">

```typescript
import { MCPClient } from "mcp-use/client";

const client = MCPClient.fromDict(config);

// Create sessions
await client.createAllSessions();

// List available tools
const tools = await client.getTools();
console.log("Tools:", tools);

// Get a specific session
const session = client.getSession("filesystem");

// Call a tool
const result = await session.callTool("read_file", {
  path: "/tmp/test.txt",
});
console.log("File content:", result.content[0].text);

// List resources
const resources = await session.listResources();
console.log("Resources:", resources);

// Read a resource
const data = await session.readResource("app://config");
console.log("Config:", data);

// Close sessions
await client.closeAllSessions();
```

  </Tab>
  
  <Tab title="Python">

```python
from mcp_use import MCPClient

client = MCPClient.from_dict(config)

# Create sessions
await client.create_all_sessions()

# List available tools
tools = await client.get_tools()
print(f"Tools: {tools}")

# Get a specific session
session = client.get_session("filesystem")

# Call a tool
result = await session.call_tool(
    name="read_file",
    arguments={"path": "/tmp/test.txt"},
)
print(f"File content: {result.content[0].text}")

# List resources
resources = await session.list_resources()
print(f"Resources: {resources}")

# Read a resource
data = await session.read_resource("app://config")
print(f"Config: {data}")

# Close sessions
await client.close_all_sessions()
```

  </Tab>
</Tabs>

### Session Management

<Tabs>
  <Tab title="TypeScript">

```typescript
// Create specific sessions
await client.createSession("filesystem");

// Check if session exists
if (client.hasSession("filesystem")) {
  const session = client.getSession("filesystem");
}

// Get all sessions
const sessions = client.getSessions();

// Close specific session
await client.closeSession("filesystem");

// Close all sessions
await client.closeAllSessions();
```

  </Tab>
  
  <Tab title="Python">

```python
# Create specific session
await client.create_session("filesystem")

# Check if session exists
if client.has_session("filesystem"):
    session = client.get_session("filesystem")

# Get all sessions
sessions = client.get_sessions()

# Close specific session
await client.close_session("filesystem")

# Close all sessions
await client.close_all_sessions()
```

  </Tab>
</Tabs>

## Multi-Server Setup

Connect to multiple servers simultaneously:

```typescript
const config = {
  mcpServers: {
    // Local process
    filesystem: {
      command: "npx",
      args: ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
    },
    // HTTP server
    weather: {
      url: "http://localhost:3000/mcp",
    },
    // Another local process
    airbnb: {
      command: "npx",
      args: ["-y", "@openbnb/mcp-server-airbnb"],
    },
  },
};

const client = MCPClient.fromDict(config);
await client.createAllSessions();

// Use tools from any server
const allTools = await client.getTools();
// Tools from all three servers are available
```

## Authentication

### OAuth Configuration

For servers requiring OAuth:

```typescript
const config = {
  mcpServers: {
    linear: {
      url: "http://localhost:3000/mcp",
      oauth: {
        clientId: process.env.LINEAR_CLIENT_ID,
        clientSecret: process.env.LINEAR_CLIENT_SECRET,
        authorizationUrl: "https://linear.app/oauth/authorize",
        tokenUrl: "https://api.linear.app/oauth/token",
        scopes: ["read", "write"],
      },
    },
  },
};
```

### Custom Headers

Add authentication headers:

```typescript
const config = {
  mcpServers: {
    api: {
      url: "https://api.example.com/mcp",
      headers: {
        "Authorization": `Bearer ${process.env.API_TOKEN}`,
        "X-API-Key": process.env.API_KEY,
      },
    },
  },
};
```

## Error Handling

<Tabs>
  <Tab title="TypeScript">

```typescript
try {
  const client = MCPClient.fromDict(config);
  await client.createAllSessions();
  
  const session = client.getSession("filesystem");
  const result = await session.callTool("read_file", {
    path: "/nonexistent.txt",
  });
  
  console.log(result);
} catch (error) {
  if (error.code === "FILE_NOT_FOUND") {
    console.error("File not found");
  } else if (error.code === "PERMISSION_DENIED") {
    console.error("Permission denied");
  } else {
    console.error("Error:", error.message);
  }
} finally {
  await client.closeAllSessions();
}
```

  </Tab>
  
  <Tab title="Python">

```python
try:
    client = MCPClient.from_dict(config)
    await client.create_all_sessions()
    
    session = client.get_session("filesystem")
    result = await session.call_tool(
        name="read_file",
        arguments={"path": "/nonexistent.txt"},
    )
    
    print(result)
except FileNotFoundError:
    print("File not found")
except PermissionError:
    print("Permission denied")
except Exception as e:
    print(f"Error: {e}")
finally:
    await client.close_all_sessions()
```

  </Tab>
</Tabs>

## Best Practices

<AccordionGroup>
  <Accordion title="Always Close Sessions">
    ```typescript
    try {
      const client = MCPClient.fromDict(config);
      await client.createAllSessions();
      // ... use client ...
    } finally {
      await client.closeAllSessions();
    }
    ```
  </Accordion>
  
  <Accordion title="Handle Connection Failures">
    ```typescript
    try {
      await client.createSession("remote-server");
    } catch (error) {
      console.error("Failed to connect:", error);
      // Fall back to alternative server or cached data
    }
    ```
  </Accordion>
  
  <Accordion title="Use Configuration Files">
    - Store configs in version control
    - Use environment variables for secrets
    - Different configs for dev/staging/prod
    - Document available servers
  </Accordion>
  
  <Accordion title="Validate Tool Inputs">
    ```typescript
    const result = await session.callTool("process_data", {
      input: validateInput(userInput),
    });
    ```
  </Accordion>
</AccordionGroup>

## Testing Connections

### Using the Inspector

The easiest way to test connections:

```bash
# For HTTP servers
npx @mcp-use/inspector --url http://localhost:3000/mcp

# For built-in servers
# Just open http://localhost:3000/inspector
```

### Programmatic Testing

<Tabs>
  <Tab title="TypeScript">

```typescript
async function testConnection() {
  const client = MCPClient.fromDict({
    mcpServers: {
      test: {
        url: "http://localhost:3000/mcp",
      },
    },
  });
  
  try {
    await client.createAllSessions();
    const tools = await client.getTools();
    
    console.log("✅ Connection successful");
    console.log(`Found ${tools.length} tools`);
    
    return true;
  } catch (error) {
    console.error("❌ Connection failed:", error);
    return false;
  } finally {
    await client.closeAllSessions();
  }
}

testConnection();
```

  </Tab>
  
  <Tab title="Python">

```python
async def test_connection():
    client = MCPClient.from_dict({
        "mcpServers": {
            "test": {
                "url": "http://localhost:8000/mcp",
            },
        }
    })
    
    try:
        await client.create_all_sessions()
        tools = await client.get_tools()
        
        print("✅ Connection successful")
        print(f"Found {len(tools)} tools")
        
        return True
    except Exception as e:
        print(f"❌ Connection failed: {e}")
        return False
    finally:
        await client.close_all_sessions()

import asyncio
asyncio.run(test_connection())
```

  </Tab>
</Tabs>

## Common Issues

<AccordionGroup>
  <Accordion title="Connection Refused">
    **Problem**: Cannot connect to server
    
    **Solutions**:
    - Verify server is running
    - Check port is correct
    - Ensure no firewall blocking
    - For HTTP, check URL is reachable
  </Accordion>
  
  <Accordion title="Tool Not Found">
    **Problem**: Tool exists on server but not accessible
    
    **Solutions**:
    - Verify server registered the tool
    - Check tool name spelling
    - Ensure session is created
    - Check server logs for errors
  </Accordion>
  
  <Accordion title="Timeout Errors">
    **Problem**: Operations timing out
    
    **Solutions**:
    - Increase timeout in client config
    - Check network latency
    - Optimize slow server operations
    - Use progress callbacks for long ops
  </Accordion>
  
  <Accordion title="Session Errors">
    **Problem**: Session not found or closed
    
    **Solutions**:
    - Always create sessions before use
    - Don't close sessions while using them
    - Handle connection drops gracefully
    - Implement retry logic
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Build AI Agents" icon="robot" href="/guides/creating-agents">
    Use MCPClient to build intelligent AI agents
  </Card>
  <Card title="Build Servers" icon="server" href="/guides/building-your-first-server">
    Create your own MCP servers
  </Card>
  <Card title="API Reference" icon="book" href="/api-reference">
    Complete client API documentation
  </Card>
  <Card title="Examples" icon="code" href="https://github.com/mcp-use/mcp-use/tree/main/libraries/typescript/packages/mcp-use/examples/client">
    Browse client examples
  </Card>
</CardGroup>
